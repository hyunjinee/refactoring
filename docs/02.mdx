---
sidebar_position: 2
---

# 2장 리팩터링 원칙

리팩터링: [명사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법  
리팩터링(하다): [동사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성하다.

앞에서 제시한 정의를 따르면 특정한 방식에 따라 코드를 정리하는 것만이 리팩터링이다. 리팩터링은 결국 동작을 보존하는 작은 단계들을 거쳐서 코드를 수정하고, 이러한 단계들을 순차적으로 연결하여 큰 변화를 만들어 내는 일이다.
개별 리팩터링은 그 자체로 아주 작을 수도 있고, 작은 단계가 여러 개가 합쳐진 모습일 수도 있다. 따라서 리팩터링하는 동안에는 코드가 항상 정상 작동하기 때문에 전체 작업이 끝나지 않았더라고 언제든 멈출 수 있다.
한편, 리팩터링 과정에서 발견된 버그는 리팩터링 후에도 그대로 남아야한다. 리팩터링은 성능 최적화와 비슷하다. 둘다 코드를 변경하지만 프로그램의 전반적인 기능은 그대로 유지한다.  
단지 목적이 다를 뿐이다. 리팩터링의 목적은 코드를 이해하고 수정하기 쉽게 만드는 것이다. 프로그램 성능은 좋아질 수도, 나빠질 수도 있다. 반면 성능 최적화는 오로지 속도 개선에만 신경쓴다. 그래서 목표 성능에 반드시 도달해야 한다면 코드는 다루기에 더 여렵게 바뀔 수도 있음을 각오해야한다.

## 리팩터링을 하는 이유

리팩터링을 하지 않으면 소프트웨어의 내부 설계가 썩기 쉽다. 아키텍처를 충분히 이해하지 못한채 단기 목표만을 위해 코드를 수정하다 보면 기반 구조가 무너지기 쉽다.
코드만으로 설계를 파악하기 어려워질수록 설계를 유지하기 어려워지고, 설계가 부패되는 속도는 더욱 빨라진다. 반면 규칙적인 리팩터링은 코드의 구조를 지탱해줄 것이다.

**리팩터링하면 소프트웨어를 이해하기 쉬워진다**  
프로그래밍은 여러 면에서 마치 컴퓨터와 대화하는 것과 같다. 컴퓨터에게 시킬 일을 표현하는 코드를 작성하면, 컴퓨터는 정확히 시킨대로 반응한다. 그래서 컴퓨터에게 시키려는 일과 이를 표현한 코드의 차이를 최대한 줄여야한다.  
문제는 프로그램을 동작시키는데만 신경쓰다 보면 나중에 그 코드를 다룰 개발자를 배려하지 못한다.

**리팩터링하면 버그를 쉽게 찾을 수 있다**
코드를 이해하기 쉽다는 말은 버그를 찾기 쉽다는 말이기도 하다. 리팩터링은 코드가 하는 일을 깊이 파악하게 되면서 새로 깨달은 것을 곧바로 코드에 반영하게 된다.  
프록램의 구조를 명확하게 다듬으려면 그냥 '이럴 것이다'라고 가정하던 점들이 분명히 드러나는데, 버그를 지나치려야 지나칠 수 없을 정도까지 명확해진다.

**리팩터링하면 프로그래밍 속도를 높일 수 있다**  
내부 설계가 잘 된 소프트웨어는 새로운 기능을 추가할 지점과 어떻게 고칠지를 쉽게 찾을 수 있다. 모듈화가 잘 되어있으면 전체 코드베이스중 작은 일부만 이해하면 된다.  
코드가 명확하면 버그를 만들 가능성도 줄고, 버그를 만들더라도 디버깅하기 좋다. 내부 품질이 뛰어난 코드 베이스는 새 기능 구축을 돕는 견과한 토대가 된다.  
내부 설계에 심혈을 기울이면 소프트웨어의 지구력이 높아져서 빠르게 개발할 수 있는 상태를 더 오래 지속할 수 있다.

**계획된 리팩터링과 수시로 하는 리팩터링**  
보기 싫은 코드를 발견하면 리팩터링 하자. 잘 작성된 코드 역시 수많은 리팩터링을 거쳐야한다.  
무엇을 수정하려 할 때는 먼저 수정하기 쉽게 정돈하고(단, 만만치 않을 수 있다) 그런 다음에 수정하자.  
리팩터링에 소홀히 했다면, 따로 시간을 내서 새 기능을 추가하기 쉽도록 코드베이스를 개선할 필요가 있다.

버전 관리 시스템에서 리팩터링 커밋과 기능 추가 커밋을 분리해야 한다는 조언을 들은 적이 있다. 이렇게 할 때의 장점은 두가지 활동을 구분해서 별개로 검토하고 승인 할 수 있다는 것이다.  
리팩터링은 기능 추가와 밀접하게 엮인 경우가 너무나 많기 때문에 굳이 나누는 것은 시간 낭비일 수 있다. 또한 해당 리팩터링을 하게 된 맥락 정보가 사라져서 왜 그렇게 수정했는지 이해하기 어려워진다.  
리팩터링 커밋을 분리한다고 해서 무조건 좋은 것은 아님을 명심하고, 여러분의 팀에 적합한 방식을 실험해 찾아야한다.

**오래 걸리는 리팩터링**  
리팩터링은 코드의 동작을 깨트리지 않는다.
라이브러리를 교체할 때는 기존의 것과 새 것 모두를 포용하는 추상 인터페이스부터 마련한다. 기존 코드가 이 추상 인터페이스를 호출하도록 만들고 나면 라이브러리를 훨씬 쉽게 교체할 수 있다. (추상화로 갈아타기. Branch By Abstaction)

프로개발자에게 주어진 임무는 새로운 기능을 빠르게 구현하는 것이고, 가장 빠른 방법은 리팩터링이다. 그래서 리팩터링부터 한다.

## 리팩터링 시 고려할 문제

리팩터링의 궁극적인 목적은 개발 속도를 높여서, 더 적은 노력으로 더 많은 가치를 창출하는 것이다.  
리팩터링의 본질은 코드베이스를 예쁘게 꾸미는데 있지 않다. 오로지 경제적인 이유로 하는 것이다.  
리팩터링은 개발 기간을 단축하고자 하는 것이다.

### 브랜치

4주간 작업한 브랜치들을 통합하는 노력은 2주간 작업한 브랜치들을 통합할 때보다 두배 이상 든다. 이 때문에 기능별 브랜치의 통합 주기를 2~3일 단위로 짧게 관리해야 한다고 주장하는 사람이 많다.  
이 방식을 지속적 통합 (Continuous Integration)이라고 한다. 또는 트렁크 기반 개발(Trunk Based Development)이라고 한다.

CI에 따르면 모든 팀원이 하루에 최소 한 번은 마스터와 통합한다. 이렇게 하면 다른 브랜치들과의 차이가 크게 벌어지는 브랜치가 없어서 머지의 복잡도를 상당히 낮출 수 있다.  
하지만 CI를 적용하기 위해 치러야할 대가가 있다. 마스터를 건강하게 유지하고, 거대한 기능을 잘게 쪼개는 법을 배우고, 각 기능을 끌 수 있는 기능 토글(기능 플래그)를 적용하여 완료되지 않은 기능이 시스템 전체를 망치지 않도록 해야한다.

머지의 복잡도를 줄일 수 있어서 CI를 선호하기도 하지만, 가장 큰 이유는 리팩터링과 궁합이 아주 좋기 때문이다.

### 테스팅

리팩터링의 두드러진 특성은 프로그램의 겉보기 동작은 똑같이 유지된다는 것이다.  
테스트 코드는 리팩터링을 할 수 있게 해줄 뿐만 아니라, 새 기능 추가도 훨씬 안전하게 진행할 수 있도록 도와준다.  
테스트 주기가 짧다면 단 몇줄만 비교하면 되며, 문제를 일으킨 부분이 그 몇줄 안에 있기 때문에 버그를 훨씬 쉽게 찾을 수 있다.

자가 테스트 코드는 통합 과정에서 발생하는 의미 충돌을 잡는 메커니즘으로 활용할 수 있어서 자연스럽게 CI와도 밀접하게 연관된다.  
CI에 통합된 테스트는 XP의 권장사항이자 지속적 배포 (Continuous Delivery)의 핵심이기도 하다.

## 리팩터링과 소프트웨어 개발 프로세스

XP의 두드러진 특징은 지속적 통합, 자가테스트 코드, 리팩터링등의 개성이 강하면서 상호 의존하는 기법들을 하나로 묶은 프로세스라는 점이다.  
참고로 자가 테스트코드와 리팩터링을 묶어서 테스트 주도 개발(Test-Driven Development)라고 한다.

리팩터링의 첫 번째 토대는 자가 테스트 코드이다. 다시 말해 프로그래밍 도중 발생한 오류를 확실히 걸러내는 테스트를 자동으로 수행할 수 있어야 한다.

지속적 통합을 적용하면 팀원 각자가 수행한 리팩터링 결과를 빠르게 동료와 공유할 수 있다.  
자가 테스트 코드는 지속적 통합의 핵심 요소이다. 따라서 자가 테스트 코드, 지속적 통합, 리팩터링이라는 세 기법은 서로 강력한 상승효과를 발휘한다.

지속적 배포는 소프트웨어를 언제든 릴리스 할 수 있는 상태로 유지해준다. 그러면 가령 웹사이트를 개발하는 조직은 수정사항을 하루에도 여러차례 릴리스 할 수 있다.  
게다가 위험 요소도 줄이고, 기술적인 제약보다는 비즈니스 요구에 맞춰 릴리스 일정을 계획할 수 있다. 이처럼 견고한 기술적 토대를 갖추면 좋은 아이디어를 프로덕션 코드로 반영하는 시간을 엄청나게 단축할 수 있어서 고객에게 더 나은 서비스를 제공할 수 있다.  
더욱이 고치는데 시간을 잡아먹는 버그의 수를 줄여줘서 소프트웨어의 신뢰도를 높일 수 있다.

## 리팩터링과 성능

직관적인 설계 vs 성능은 중요한 주제이다. 내가 성능을 무시하는 이유는 설계의 순수성을 우선시하거나 조만간 더 빠른 하드웨어가 나오리라 믿기 때문이 아니다.  
리팩터링하면 소프트웨어가 느려질 수도 있는 건 사실이다. 하지만 그와 동시에 성능을 튜닝하기에 쉬워진다.  
소프트웨어를 빠르게 만드는 비결은, 먼저 튜닝하기 쉽게 만들고 나서 원하는 속도가 나게끔 튜닝하는 것이다.

성능 최적화에 들어가기 전까지는 성능에 신경 쓰지 않고 코드를 다루기 쉽게 만드는데 집중한다.  
성능 최적화 단계가 되면 다음 구체적인 절차를 따라 프로그램을 튜닝한다.

1. 프로파일러로 프로그램을 분석하여 시간과 공간을 많이 잡아먹는 지점을 알아낸다.
2. 성능에 큰 영향을 주는 작은 부분들을 찾아 그 부분들을 개선한다.

## 리팩터링의 유래

리팩터링이란 용어의 정확한 유래는 찾을 수 없다.  
실력 있는 프로그래머는 항상 자신의 코드를 정리하는데 어느 정도의 시간을 할애해왔다.  
복잡하고 지저분한 코드보다는 깔끔한 코드가 수정하기 쉽고, 처음부터 깔끔하게 작성하는 경우는 거의 없다는 것을 경험을 통해 알기 때문이다.
